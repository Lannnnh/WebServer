# 日志设计与实现

## 日志的设计

​	日志（Log）是用来故障诊断和追踪使用的，当然也可以用来性能分析。对于关键进程，日志通常要记录

1. 收到的每条内部消息和id
2. 收到的每条外部消息的全文
3. 发出的每条消息的全文，每条消息都有全局唯一的id
4. 关键内部状态的变更，等等

​	 每条日志都有时间戳，这样就能完整追踪分布式系统中一个事件的来龙去脉。也只有这样才能查清楚故障发生时究竟发生了什么，业务处理卡在了哪一步。

​	一个日志大体可以分为**前端**和**后端**两部分。前端是供应用程序使用的接口（API），并生成日志消息；后端则负责把日志消息写到目的地。这两部分的接口有时候有可能简单到只有一个回调函数。在多线程程序中，前端和后端都与单线程程序没有什么去呗，无非是每个线程都有自己的前端，整个程序公用一个后端。这就是典型的多生产者-单消费者问题，对生产者（前端）而言，要尽量做到低延迟、低CPU开销、无阻塞；对消费者（后端）而言，要做到足够大的吞吐量，并占用较少的资源。

​	上面是日志的一个大体设计模式，下面来讲一讲本项目的日志设计。就像前面所说的日志分为前端和后端，在项目里那么前端必然就是**供每一个线程调用的接口（API）**，后端是一个**Log线程**，包含了多个缓冲区，专门负责收集前端产生的Log信息，然后集中往目的地（本地文件）写。这种后端的设计方式被称为“异步日志”，用一个背景线程负责收集日志消息，并写入日志文件，其他业务线程只管往这个“日志线程”发送日志消息。这样设计避免了用一个全局mutex保护IO,或者每个IO线程单独写一个日志文件，从而得到更高的效率。

​	该项目日志采用的是“双缓冲技术”，基本思路是准备两块Buffer：A和B，前端负责往Buffer A写日志消息，后端负责将Buffer B的日志文件写入本地文件，而前端则往B填入新的日志消息，如此往复。用两块Buffer的好处是在新建日志消息的时候不必等到磁盘文件操作，也避免了每条新日志文件都唤醒后端日志线程。简单来说，前端不是一条条日志消息发送给后端，而是把一大批日志消息一起发送给后端，相当于批处理，减少了唤醒后端的次数，降低开销。

## 日志的实现

​	在该项目里，日志实现主要包括AsyncLogging、FileUtil、LogFile、LogStream和Logging五个类。

1.  FileUtil最底层的文件类，在构造的时候创建Log文件，析构的时候关闭Log文件，使用了标准IO函数，append函数直接向Log文件写入，flush函数清除缓冲区数据并写入到Log文件中。
2.  LogFile是FileUtil更上层的一个类，FileUtil被封装在LogFile里面。LogFile多了一个flushEvertN_数据成员，设置了一个flush的阈值，当append次数超过这个阈值的时候就flush一次。
3.  该日志库是C++ stream风格，LogStream这个类就是用来格式化输出，重载了<<运算符，它拥有一块自己的缓冲区，主要是用来把输出信息放到一块缓冲区里，把多个<<的信息结合成一行。
4.  AsyncLogging就是Log线程，是日志库的核心。就像上面日志的设计里说道的，AsyncLogging用到了“双缓冲技术”，在缓冲区被填满或者定时超时时将缓冲区中的日志消息写入到LogFile中。
5.  Logging类就包含了上面的四个类，封装起来成为对外调用的接口，供其他线程写入日志消息使用。	