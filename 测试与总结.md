# 测试与总结

## 测试

WebBench是Linux下的一款压力测试工具，通过它来测试WebServer和muduo在相同硬件下的性能。

**测试环境**（WebBench和http服务器用一个虚拟机测试性能可能较低）

-   设置300个并发连接，测试时间60s
-   内存： 2G
-   OS： ubuntu 18.04.2
-   WebBench默认短连接

可以看到WebServer相对于muduo能处理的请求数还是还低上一截，目前服务器在IO多路复用使用的是Poll，而muduo使用的是Epoll，我感觉在接收并发连接的效率上有可能在这里会产生一定的影响（Epoll模块快完成了，写完了再测试一下）。

-   WebServer测试结果

![WebServer](https://github.com/Lannnnh/WebServer/blob/master/photo/WebServer.png)

-   muduo测试结果

![muduo](https://github.com/Lannnnh/WebServer/blob/master/photo/muduos.png)

## 总结

### 项目初衷

这是在零基础入门学习C++网络编程过程中的一个练手的项目，最开始看书的时候经常一脸懵逼，还是要结合实验或者项目才能加深自己对书本知识的理解。

### 项目难点

1. 当一个对象被多线程管理时，会不会造成多线程对这个对象的竞争，该什么时候被析构？如果在其他线程还持有这个对象的时候，另一个线程就析构了这个对象，那么这个被持有的对象就是空悬的。

对于这个问题，可以使用C++11里面引入的Shared_ptr来解决，Shared_ptr里包含一个引用计数，只要还有一个指向对象的引用存在，那么这个对象就不会析构。

2. 多线程编程最困难理解的对于网络IO该怎么控制多线程的读写问题，是用锁来保证吗？

TCP/IP保证了数据完整性，但是那只代表内核输入/输出缓冲区接收发送的数据是完整的，Sokcet读写并不保证一次读写完整读写数据。一次read100字节但是有可能只有60字节，接下来另一个线程可能接收走了另外40字节的数据，怎么把这些数据拼成完整的数据？用锁来管理可以保证一次只有一个线程来读写这个socket，但是这样做不如让一个socket只被一个线程管理，从而解决了收发消息的顺序和完整性问题，不存在线程之间的竞争。

3.  文件描述符之间的串话（当一个线程A正准备read某个socket时，线程B却close了这个socket， 并且线程C重新open了一个新的和以前相同号码的socket，那么线程A就读取到了意料之外的数据）应该怎样处理？

其实也是后面从书上看到的这种编程思想很好的解决了这个问题：RAII。可以把Socket作为一个类包装起来，当构造它的时候分配socket，读写操作都在封装在里面，当它析构的时候自动close掉这个socket，这样就避免了串话。

